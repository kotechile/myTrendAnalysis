// ============================================================================
// ============================================================================

// ========================================================================
// INITIALIZATION & CONFIGURATION
// ========================================================================

// User Authentication
const userData = await Noodl.Variables.supabase.auth.getUser();
const userID = userData.data.user.id;
const supabase = Noodl.Variables.supabase;
const sub_topics_csv = Inputs.sub_topics_csv || "";
const subtopics = sub_topics_csv ? 
    sub_topics_csv.split(',')
        .map(s => s.trim())
        .filter(s => s.length > 0) : 
    []; // Optional manual subtopics

// Input Configuration
const loadMode = Inputs.loadModeState || "new";
const selectedAnalysisId = Inputs.selectedAnalysisId;
const currentTab = Inputs.currentTab || "overview";
const filterSettings = Inputs.filterSettings || {};
const sortSettings = Inputs.sortSettings || {};
const trends_url = Inputs.trends_url || 'http://localhost:8001';

// Selection Management
const selectionAction = Inputs.selectionAction;
const targetId = Inputs.targetId;
const targetType = Inputs.targetType;
const bulkSelectionType = Inputs.bulkSelectionType || "";

// New Analysis Parameters
const topic = Inputs.topic?.trim() || "";
const focusArea = Inputs.focusArea || "general";
const targetAudience = Inputs.targetAudience || "professional";

// Affiliate Research Configuration
const enableAffiliateResearch = Inputs.enableAffiliateResearch || false;
const minAffiliateScore = Inputs.minAffiliateScore || 30;
const minCommissionThreshold = Inputs.minCommissionThreshold || 25;



// LLM Configuration
const llmProvider = Inputs.llm_provider || "openai";
const llmProviderMap = {
    'gemini': { model: Inputs.geminiModel || "gemini-2.0-flash", key: Inputs.geminiKey },
    'openai': { model: Inputs.openaiModel || "gpt-4o-mini", key: Inputs.openaiKey },
    'deepseek': { model: Inputs.deepseekModel || "deepseek-chat", key: Inputs.deepseekKey },
    'anthropic': { model: Inputs.anthropicModel || "claude-3-sonnet-20240229", key: Inputs.anthropicKey },
    'kimi': { model: Inputs.kimiModel || "", key: Inputs.kimiKey }
};

const { model, key: llmKey } = llmProviderMap[llmProvider] || llmProviderMap.openai;

// ========================================================================
// ENHANCED UTILITY FUNCTIONS
// ========================================================================

const Utils = {

    getProfitabilityLevel: (score) => {
        if (score >= 70) return 'Excellent';
        if (score >= 50) return 'Good';
        if (score >= 30) return 'Moderate';
        return 'Poor';
    },

    getProfitabilityColor: (score) => {
        if (score >= 70) return '#10b981';
        if (score >= 50) return '#f59e0b';
        if (score >= 30) return '#f97316';
        return '#ef4444';
    },

    getProfitabilityIcon: (score) => {
        if (score >= 70) return '💰';
        if (score >= 50) return '💵';
        if (score >= 30) return '💸';
        return '⚠️';
    },
    calculateOpportunityScore: (topic) => {
        const viralWeight = topic.viral_potential * 0.4;
        const volumeWeight = (topic.search_volume === 'High' ? 30 : topic.search_volume === 'Medium' ? 20 : 10) * 0.3;
        const competitionWeight = (topic.competition === 'Low' ? 30 : topic.competition === 'Medium' ? 20 : 10) * 0.3;
        return Math.round(viralWeight + volumeWeight + competitionWeight);
    },

    calculateOverallScore: (opportunity) => {
        const engagementScore = opportunity.engagement_potential === 'High' ? 30 : opportunity.engagement_potential === 'Medium' ? 20 : 10;
        const difficultyScore = 30 - (opportunity.difficulty * 0.3);
        return Math.round(engagementScore + difficultyScore);
    },


    // Enhanced Monetization Functions (from original code)
    calculateMonetizationScore: (item) => {
        let score = 50; // Base score
        
        // Adjust based on item type
        if (item.viral_potential) {
            score += (item.viral_potential * 0.3);
            if (item.search_volume === 'High') score += 15;
            else if (item.search_volume === 'Medium') score += 10;
            if (item.competition === 'Low') score += 15;
            else if (item.competition === 'Medium') score += 10;
        } else if (item.engagement_potential) {
            score += (item.engagement_potential === 'High' ? 25 : item.engagement_potential === 'Medium' ? 15 : 5);
            score += (100 - item.difficulty) * 0.2;
        }
        
        return Math.min(100, Math.max(0, Math.round(score)));
    },

    estimateRevenueRange: (item) => {
        const monetizationScore = Utils.calculateMonetizationScore(item);
        
        if (monetizationScore >= 80) return "$10,000 - $25,000";
        if (monetizationScore >= 60) return "$5,000 - $15,000";
        return "$2,000 - $8,000";
    },

    // Missing monetization priority function
    getMonetizationPriority: (score) => {
        if (score >= 80) return 'High';
        if (score >= 60) return 'Medium';
        return 'Low';
    },

    getMonetizationIcon: (score) => {
        if (score >= 80) return '💰';
        if (score >= 60) return '💵';
        if (score >= 40) return '💸';
        return '⚠️';
    },

    getMonetizationColor: (score) => {
        if (score >= 80) return '#10b981';
        if (score >= 60) return '#f59e0b';
        if (score >= 40) return '#f97316';
        return '#ef4444';
    },

    // Missing viral score and difficulty functions
    getViralScoreIcon: (score) => {
        if (score >= 80) return '🔥';
        if (score >= 60) return '⚡';
        if (score >= 40) return '📈';
        return '📊';
    },

    getViralScoreColor: (score) => {
        if (score >= 80) return '#ef4444';
        if (score >= 60) return '#f97316';
        if (score >= 40) return '#f59e0b';
        return '#6b7280';
    },

    getOpportunityLevel: (viralPotential) => {
        if (viralPotential >= 80) return 'High';
        if (viralPotential >= 60) return 'Medium';
        return 'Low';
    },

    getDifficultyLevel: (difficulty) => {
        if (difficulty <= 40) return 'Beginner';
        if (difficulty <= 60) return 'Intermediate';
        if (difficulty <= 80) return 'Advanced';
        return 'Expert';
    },

    getDifficultyColor: (difficulty) => {
        if (difficulty <= 40) return '#10b981';
        if (difficulty <= 60) return '#f59e0b';
        if (difficulty <= 80) return '#f97316';
        return '#ef4444';
    },

    getContentFormatIcon: (format) => {
        const icons = {
            'how_to_guide': '📋',
            'video': '🎥',
            'podcast': '🎙️',
            'course': '🎓',
            'guide': '📖',
            'checklist': '✅',
            'template': '📄',
            'listicle': '📝',
            'case_study': '📊',
            'comparison': '⚖️',
            'product_review': '⭐',
            'blog_post': '📝'
        };
        return icons[format] || '📄';
    },

    // Missing monetization streams identification
    identifyMonetizationStreams: (item) => {
        const streams = [];
        
        if (!item) return streams;
        
        // Affiliate marketing
        streams.push({
            type: 'affiliate',
            priority: 'medium',
            description: 'Product recommendations with commission',
            potential: '$100-$1000+ per month'
        });
        
        // Sponsored content
        if (item.viral_potential && item.viral_potential >= 70) {
            streams.push({
                type: 'sponsored',
                priority: 'high',
                description: 'Brand partnerships and sponsored posts',
                potential: '$200-$2000+ per post'
            });
        }
        
        // Lead generation
        if (item.search_volume && item.search_volume === 'high') {
            streams.push({
                type: 'lead_gen',
                priority: 'medium',
                description: 'Lead magnets and email capture',
                potential: '$50-$500+ per lead'
            });
        }
        
        // Digital products
        streams.push({
            type: 'digital_product',
            priority: 'medium',
            description: 'Courses, templates, guides',
            potential: '$500-$5000+ per product'
        });
        
        return streams;
    },

    // Enhanced logging utility
    log: (level, message, data = null) => {
        const timestamp = new Date().toISOString();
        const logMessage = `[${timestamp}] ${level.toUpperCase()}: ${message}`;
        
        console.log(logMessage);
        if (data) {
            console.log('Data:', JSON.stringify(data, null, 2));
        }
        
        return logMessage;
    },

    // Validation and safety functions
    validateUUID: (id) => {
        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        return uuidRegex.test(id);
    },

    safeGet: (obj, path, defaultValue = null) => {
        return path.split('.').reduce((current, key) => current?.[key], obj) ?? defaultValue;
    },

    // Safe array operations
    safeArray: (arr, defaultArr = []) => {
        return Array.isArray(arr) ? arr : defaultArr;
    }
};

// Initialize Outputs object to prevent undefined errors
if (typeof Outputs === 'undefined') {
    Outputs = {};
}

// Ensure Outputs.SelectionSummary exists
Outputs.SelectionSummary = Outputs.SelectionSummary || {
    selectedTopics: 0,
    totalTopics: 0,
    selectedOpportunities: 0,
    totalOpportunities: 0,
    readyForPhase2: false,
    totalSelections: 0,
    selectionProgress: 0,
    hasHighPotentialSelections: false
};

// Initialize MarketTrendSummary to prevent null issues
Outputs.MarketTrendSummary = Outputs.MarketTrendSummary || {
    analysisId: "",
    topic: "",
    confidenceScore: 0,
    trendingTopics: [],
    contentOpportunities: [],
    keywordIntelligence: {},
    geographicInsights: [],
    seasonalPatterns: {},
    actionableInsights: [],
    totalEstimatedRevenue: "$0 - $0",
    isLoading: false,
    error: null
};


// ========================================================================
// ENHANCED DATA ACCESS FUNCTIONS
// ========================================================================

const DataAccess = {

    async loadDataWithOrderPreservation(analysisId) {
        console.log(`📊 Loading data for analysis: ${analysisId}`);

    try {
        const [analysisResponse, topicsResponse, opportunitiesResponse, keywordResponse, affiliateResponse] = await Promise.all([
            supabase.from('trend_analyses').select('*').eq('id', analysisId).eq('user_id', userID).single(),
            supabase.from('trending_topics').select('*').eq('trend_analysis_id', analysisId).eq('user_id', userID)
                .order('viral_potential', { ascending: false }).order('created_at', { ascending: true }),
            supabase.from('content_opportunities').select('*').eq('trend_analysis_id', analysisId).eq('user_id', userID)
                .order('difficulty', { ascending: true }).order('created_at', { ascending: true }),
            supabase.from('keyword_intelligence').select('*').eq('trend_analysis_id', analysisId).eq('user_id', userID).maybeSingle(),
            // NEW: Get affiliate profitability data
            this.getAffiliateProfitabilityForAnalysis(analysisId, userID)
        ]);

            // Error handling
            [analysisResponse, topicsResponse, opportunitiesResponse].forEach(response => {
                if (response.error) throw response.error;
            });

 const trendingTopics = topicsResponse.data.map((topic, index) => ({
            ...topic,
            displayRank: index + 1,
            // NEW: Add affiliate profitability score
            affiliate_profitability_score: affiliateResponse?.profitability_score || 0,
            monetization_score: Utils.calculateMonetizationScore({
                ...topic, 
                affiliate_profitability_score: affiliateResponse?.profitability_score || 0
            }),
            estimated_revenue_range: Utils.estimateRevenueRange({
                ...topic, 
                affiliate_profitability_score: affiliateResponse?.profitability_score || 0
            }),
            monetization_priority: Utils.getMonetizationPriority(Utils.calculateMonetizationScore(topic)),
            monetization_streams: Utils.identifyMonetizationStreams(topic)
        }));

        const contentOpportunities = opportunitiesResponse.data.map((opp, index) => ({
            ...opp,
            displayRank: index + 1,
            // NEW: Add affiliate profitability score
            affiliate_profitability_score: affiliateResponse?.profitability_score || 0,
            monetization_score: Utils.calculateMonetizationScore({
                ...opp, 
                affiliate_profitability_score: affiliateResponse?.profitability_score || 0
            }),
            estimated_revenue_range: Utils.estimateRevenueRange({
                ...opp, 
                affiliate_profitability_score: affiliateResponse?.profitability_score || 0
            }),
            monetization_priority: Utils.getMonetizationPriority(Utils.calculateMonetizationScore(opp)),
            monetization_streams: Utils.identifyMonetizationStreams(opp)
        }));


      return {
            analysis_info: analysisResponse.data,
            trending_topics: trendingTopics,
            content_opportunities: contentOpportunities,
            keyword_intelligence: keywordResponse.data || {},
            affiliate_research_data: affiliateResponse
        };

    } catch (error) {
        console.error("❌ Data loading failed:", error);
        throw new Error(`Failed to load data: ${error.message}`);
    }
},

async getAffiliateProfitabilityForAnalysis(analysisId, userID) {
    try {
        // Get trend analysis topic
        const { data: analysis, error: analysisError } = await supabase
            .from('trend_analyses')
            .select('topic')
            .eq('id', analysisId)
            .eq('user_id', userID)
            .single();

        if (analysisError || !analysis) return null;

        // Get affiliate session for this topic
        const { data: session, error: sessionError } = await supabase
            .from('affiliate_research_sessions')
            .select('id, profitability_score, profitability_level')
            .eq('topic', analysis.topic)
            .eq('user_id', userID)
            .order('created_at', { ascending: false })
            .limit(1)
            .single();

        if (sessionError || !session) return null;

        // Get detailed profitability analysis
        const { data: profitability, error: profitabilityError } = await supabase
            .from('affiliate_profitability_analysis')
            .select('*')
            .eq('research_session_id', session.id)
            .single();

        return profitability || {
            profitability_score: session.profitability_score || 0,
            profitability_level: session.profitability_level || 'unknown'
        };

    } catch (error) {
        console.error("❌ Error getting affiliate profitability:", error);
        return null;
    }
}
    
    async refreshSelectionStates(analysisId, existingTopics, existingOpportunities) {
        console.log("🔄 Refreshing selection states");

        try {
            const [topicsSelections, opportunitiesSelections] = await Promise.all([
                supabase.from('trending_topics').select('id, selected').eq('user_id', userID).eq('trend_analysis_id', analysisId),
                supabase.from('content_opportunities').select('id, selected').eq('user_id', userID).eq('trend_analysis_id', analysisId)
            ]);

            if (topicsSelections.error) throw topicsSelections.error;
            if (opportunitiesSelections.error) throw opportunitiesSelections.error;

            // Create lookup maps
            const topicSelectionMap = new Map(topicsSelections.data.map(t => [t.id, t.selected]));
            const oppSelectionMap = new Map(opportunitiesSelections.data.map(o => [o.id, o.selected]));

            // Update in place
            existingTopics.forEach(topic => {
                if (topicSelectionMap.has(topic.id)) {
                    topic.selected = topicSelectionMap.get(topic.id);
                }
            });

            existingOpportunities.forEach(opp => {
                if (oppSelectionMap.has(opp.id)) {
                    opp.selected = oppSelectionMap.get(opp.id);
                }
            });

            return { updatedTopics: existingTopics, updatedOpportunities: existingOpportunities };

        } catch (error) {
            console.error("❌ Failed to refresh selection states:", error);
            throw error;
        }
    }
};

// ========================================================================
// MAIN EXECUTION LOGIC
// ========================================================================

// Initialize outputs
Outputs.bulkSelectionStatusMessage = '';
Outputs.OverviewMetrics = [];

// Variables at function scope
let pytrendsData = null;
let pytrendsAvailable = false;
let currentInterest = 0;
let trendDirection = "unknown";
let momentum = 0;
let peakInterest = 0;
let recommendation = "";
let growthPotential = "unknown";
let geographicHotspots = [];
let seasonalPatterns = {};
let actionableInsights = [];
let relatedQueries = {};


try {
    // Set loading state
    Outputs.loading = true;
    Outputs.error = "";

    // ====================================================================
    // INPUT VALIDATION
    // ====================================================================
    
    if (loadMode === "new") {
        if (!topic) {
            throw new Error("Topic is required for new analysis");
        }
        if (!llmKey) {
            throw new Error(`API key is required for ${llmProvider}`);
        }
    } else if (loadMode === "existing") {
        if (!selectedAnalysisId || !Utils.validateUUID(selectedAnalysisId)) {
            throw new Error("Valid Analysis ID is required for loading existing data");
        }
    }

    // ====================================================================
    // ====================================================================
    
    let analysisData;
    let currentAnalysisId;
    let apiResult = null;

    if (loadMode === "new") {
        
        // Continue with enhanced trend research
        console.log("🔍 Running enhanced trend research...");
        
        const requestBody = {
            topic,
            focus_area: focusArea,
            user_id: userID,
            target_audience: targetAudience,
            llm_config: { provider: llmProvider, model, api_key: llmKey },
            linkup_api_key: Inputs.linkupKey || null,
            google_trends_api_key: Inputs.googleTrendsKey || null,
            // Enhanced monetization analysis
            enable_monetization_analysis: true,
            monetization_config: {
                include_revenue_estimates: true,
                include_stream_analysis: true,
                include_priority_scoring: true
            },
            // NEW: Add affiliate research parameters if enabled
            enable_affiliate_research: enableAffiliateResearch,
            affiliate_config: {
                min_affiliate_score: minAffiliateScore,
                min_commission_threshold: minCommissionThreshold,
                subtopics: subtopics
            }
        };

        const response = await fetch(trends_url + '/api/v2/enhanced-trend-research', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            throw new Error(`API request failed: ${response.status} ${response.statusText}`);
        }

        apiResult = await response.json();
        
        if (!apiResult.success) {
            throw new Error(apiResult.error || 'API request failed');
        }
        
        currentAnalysisId = apiResult.metadata.trend_analysis_id;
        
        console.log(`✅ New analysis completed with ID: ${currentAnalysisId}`);
        
    } else {
        console.log(`📂 Loading existing analysis: ${selectedAnalysisId}`);
        currentAnalysisId = selectedAnalysisId;
    }

    analysisData = await DataAccess.loadDataWithOrderPreservation(currentAnalysisId);
    
    // Extract variables after loading data
    const analysisInfo = analysisData.analysis_info;
    const trendingTopics = analysisData.trending_topics || [];
    const contentOpportunities = analysisData.content_opportunities || [];
    const keywordIntelligence = analysisData.keyword_intelligence || {};
    
    // Pass the complete raw Supabase data to transformer
    Outputs.RawSupabaseData = analysisData;

    console.log("📊 Data extracted:", {
        topics: trendingTopics.length,
        opportunities: contentOpportunities.length,
        avgTopicMonetization: trendingTopics.length > 0 ? Math.round(trendingTopics.reduce((sum, t) => sum + (t.monetization_score || 0), 0) / trendingTopics.length) : 0
    });

    // ========================================================================
    // CONTINUE WITH EXISTING LOGIC...
    // ========================================================================
    
    // [Rest of the existing code remains the same, but with enhanced monetization calculations]

    // ====================================================================
    // CONTINUE WITH EXISTING LOGIC...
    // ====================================================================
    
    // [Rest of the existing code remains the same, but with enhanced monetization calculations]
    // ... (selection handling, PyTrends extraction, data transformation, etc.)

    // Enhanced Market Trend Summary with Affiliate Data
    const totalEstimatedRevenue = [...trendingTopics, ...contentOpportunities]
        .reduce((sum, item) => {
            const revenueStr = item.estimated_revenue_range || "$0 - $0";
            const maxRevenue = parseInt(revenueStr.split(' - ')[1]?.replace(/[$,]/g, '') || '0') || 0;
            return sum + maxRevenue;
        }, 0);

    Outputs.MarketTrendSummary = {
        topic: analysisInfo.topic,
        focusArea: analysisInfo.focus_area,
        targetAudience: analysisInfo.target_audience,
        confidenceScore: Utils.safeGet(analysisInfo, 'metadata.confidence_score', 85),
        enhancedResearch: true,
        analysisTimestamp: analysisInfo.created_at,
        totalTrendingTopics: trendingTopics.length,
        totalOpportunities: contentOpportunities.length,
        selectedTopics: trendingTopics.filter(t => t.selected).length,
        selectedOpportunities: contentOpportunities.filter(o => o.selected).length,
        dataSource: "supabase",
        // PyTrends data (extracted later)
        googleTrendsScore: currentInterest,
        trendMomentum: momentum,
        trendDirection: trendDirection,
        topGeographicMarket: geographicHotspots.length > 0 ? geographicHotspots[0].country : "Unknown",
        seasonalTiming: seasonalPatterns.next_peak_prediction ? seasonalPatterns.next_peak_prediction.month : null,
        pytrendsEnhanced: pytrendsAvailable,
        growthPotential: growthPotential,
        totalEstimatedRevenue: totalEstimatedRevenue,
        avgMonetizationScore: Math.round([...trendingTopics, ...contentOpportunities]
            .reduce((sum, item) => sum + (item.monetization_score || 0), 0) / Math.max(trendingTopics.length + contentOpportunities.length, 1)),
        highMonetizationCount: [...trendingTopics, ...contentOpportunities].filter(item => (item.monetization_score || 0) >= 70).length,
        monetizationEnhanced: true,
    };

    // ====================================================================
    // ENHANCED PYTRENDS DATA EXTRACTION (EXISTING LOGIC)
    // ====================================================================

    console.log("📈 EXTRACTING PYTRENDS DATA...");

    if (analysisData?.analysis_info?.metadata?.pytrends_analysis) {
        pytrendsData = analysisData.analysis_info.metadata.pytrends_analysis;
        pytrendsAvailable = !!(pytrendsData && pytrendsData.pytrends_enhanced);
        
        console.log("✅ Found PyTrends data in metadata");
        
        if (pytrendsAvailable) {
            const mainAnalysis = pytrendsData.main_topic_analysis || {};
            currentInterest = mainAnalysis.current_interest || 0;
            trendDirection = mainAnalysis.trend_direction || "unknown";
            momentum = mainAnalysis.momentum_percentage || 0;
            peakInterest = mainAnalysis.peak_interest || 0;
            recommendation = mainAnalysis.recommendation || "";
            growthPotential = mainAnalysis.growth_potential || "unknown";
            
            geographicHotspots = pytrendsData.geographic_insights?.global_hotspots || [];
            seasonalPatterns = pytrendsData.seasonal_patterns || {};
            actionableInsights = pytrendsData.actionable_insights || [];
            relatedQueries = pytrendsData.related_queries_insights || {};
            
            console.log("✅ PyTrends extraction successful:", {
                currentInterest, momentum, trendDirection
            });
        }
    }

    // Update MarketTrendSummary with PyTrends data
    Outputs.MarketTrendSummary.googleTrendsScore = currentInterest;
    Outputs.MarketTrendSummary.trendMomentum = momentum;
    Outputs.MarketTrendSummary.trendDirection = trendDirection;
    Outputs.MarketTrendSummary.topGeographicMarket = geographicHotspots.length > 0 ? geographicHotspots[0].country : "Unknown";
    Outputs.MarketTrendSummary.seasonalTiming = seasonalPatterns.next_peak_prediction ? seasonalPatterns.next_peak_prediction.month : null;
    Outputs.MarketTrendSummary.pytrendsEnhanced = pytrendsAvailable;
    Outputs.MarketTrendSummary.growthPotential = growthPotential;

    // ====================================================================
    // SELECTION HANDLING (EXISTING LOGIC WITH MINOR ENHANCEMENTS)
    // ====================================================================
    
    // [Include existing selection handling code with SelectionManager...]
    
    // ====================================================================
    // ENHANCED DATA TRANSFORMATION WITH AFFILIATE INTEGRATION
    // ====================================================================
    
    const DataTransformer = {
transformTrendingTopics(topics) {
    return topics.map((topic, index) => ({
        trend: topic.title,
        description: Utils.safeGet(topic, 'additional_data.description', "AI-powered trend analysis"),
        viral_potential: topic.viral_potential,
        keywords: topic.keywords || [],
        search_volume: topic.search_volume,
        competition: topic.competition,
        relevance: Utils.safeGet(topic, 'additional_data.relevance', "high"),
        content_formats: Utils.safeGet(topic, 'additional_data.content_formats', ["how_to_guide"]),
        content_angles: Utils.safeGet(topic, 'additional_data.content_angles', []),
        selected: topic.selected || false,
        id: topic.id,
        opportunityScore: Utils.calculateOpportunityScore(topic),
        isHighPotential: topic.viral_potential >= 70,
        isQuickWin: topic.viral_potential >= 60 && topic.competition === 'Low',
        rank: topic.displayRank || (index + 1),
        monetization_score: topic.monetization_score || Utils.calculateMonetizationScore(topic),
        estimated_revenue_range: topic.estimated_revenue_range || Utils.estimateRevenueRange(topic),
        monetization_priority: topic.monetization_priority || Utils.getMonetizationPriority(topic.monetization_score || 0),
        monetization_streams: topic.monetization_streams || Utils.identifyMonetizationStreams(topic),
        isHighMonetization: (topic.monetization_score || 0) >= 70,
        monetizationIcon: Utils.getMonetizationIcon(topic.monetization_score || 0),
        monetizationColor: Utils.getMonetizationColor(topic.monetization_score || 0),
        
        // NEW: ADD AFFILIATE FIELDS
        affiliate_profitability_score: topic.affiliate_profitability_score || 0,
        hasAffiliateData: (topic.affiliate_profitability_score || 0) > 0,
        affiliateProfitabilityLevel: Utils.getProfitabilityLevel(topic.affiliate_profitability_score || 0),
        affiliateProfitabilityIcon: Utils.getProfitabilityIcon(topic.affiliate_profitability_score || 0),
        affiliateProfitabilityColor: Utils.getProfitabilityColor(topic.affiliate_profitability_score || 0)
    }));
}

        transformContentOpportunities(opportunities) {
            return opportunities.map((opp, index) => ({
                opportunity: opp.title,
                format: opp.format,
                difficulty: opp.difficulty,
                engagement_potential: opp.engagement_potential,
                time_investment: Utils.safeGet(opp, 'additional_data.time_investment', "2-3 weeks"),
                keywords: Utils.safeGet(opp, 'additional_data.keywords', []),
                monetization: Utils.safeGet(opp, 'additional_data.monetization', "Medium potential"),
                distribution: Utils.safeGet(opp, 'additional_data.distribution', ["Blog", "Social Media"]),
                selected: opp.selected || false,
                id: opp.id,
                overallScore: Utils.calculateOverallScore(opp),
                isQuickWin: opp.difficulty <= 40 && opp.engagement_potential === 'High',
                isHighValue: Utils.calculateOverallScore(opp) >= 50,
                rank: opp.displayRank || (index + 1),
                monetization_score: opp.monetization_score || Utils.calculateMonetizationScore(opp),
                estimated_revenue_range: opp.estimated_revenue_range || Utils.estimateRevenueRange(opp),
                monetization_priority: opp.monetization_priority || Utils.getMonetizationPriority(opp.monetization_score || 0),
                monetization_streams: opp.monetization_streams || Utils.identifyMonetizationStreams(opp),
                isHighMonetization: (opp.monetization_score || 0) >= 70,
                monetizationIcon: Utils.getMonetizationIcon(opp.monetization_score || 0),
                monetizationColor: Utils.getMonetizationColor(opp.monetization_score || 0),
            }));
        },

        generateTableData(topics, opportunities) {
    const topicsTableData = topics.map((topic, index) => ({
        id: topic.id,
        rank: topic.displayRank || (index + 1),
        topic: topic.title,
        viralScoreDisplay: `${Utils.getViralScoreIcon(topic.viral_potential)} ${topic.viral_potential}%`,
        opportunityLevel: Utils.getOpportunityLevel(topic.viral_potential),
        searchVolume: topic.search_volume || 'Medium',
        competition: topic.competition || 'Medium',
        primaryKeywords: (topic.keywords || []).slice(0, 3).join(', '),
        monetizationScoreDisplay: `${Utils.getMonetizationIcon(topic.monetization_score)} ${topic.monetization_score}%`,
        
        // NEW: ADD AFFILIATE SCORE DISPLAY
        affiliateScoreDisplay: topic.affiliate_profitability_score > 0 ? 
            `${Utils.getProfitabilityIcon(topic.affiliate_profitability_score)} ${topic.affiliate_profitability_score}%` : 'N/A',
        
        revenueRange: topic.estimated_revenue_range,
        monetizationPriority: topic.monetization_priority,
        topMonetizationStream: topic.monetization_streams.length > 0 ? topic.monetization_streams[0].type : 'None',
        selected: topic.selected || false,
        selectable: true,
        
        // Raw values for sorting
        viralScore: topic.viral_potential,
        opportunityScore: Utils.calculateOpportunityScore(topic),
        isHighPotential: topic.viral_potential >= 70,
        isQuickWin: topic.viral_potential >= 60 && topic.competition === 'Low',
        monetization_score: topic.monetization_score,
        
        // NEW: ADD AFFILIATE FIELDS
        affiliate_profitability_score: topic.affiliate_profitability_score || 0,
        hasAffiliateData: (topic.affiliate_profitability_score || 0) > 0,
        
        isHighMonetization: topic.monetization_score >= 70,
        stableSort: topic.displayRank || (index + 1)
    }));

    const opportunitiesTableData = opportunities.map((opp, index) => ({
        id: opp.id,
        rank: opp.displayRank || (index + 1),
        title: opp.title,
        formatWithIcon: `${Utils.getContentFormatIcon(opp.format)} ${opp.format.replace(/_/g, ' ').toUpperCase()}`,
        engagementPotential: opp.engagement_potential || 'Medium',
        difficultyDisplay: `${Utils.getDifficultyLevel(opp.difficulty)} (${opp.difficulty}/100)`,
        timeInvestment: Utils.safeGet(opp, 'additional_data.time_investment', 'Medium'),
        monetizationScoreDisplay: `${Utils.getMonetizationIcon(opp.monetization_score)} ${opp.monetization_score}%`,
        
        // NEW: ADD AFFILIATE SCORE DISPLAY
        affiliateScoreDisplay: opp.affiliate_profitability_score > 0 ? 
            `${Utils.getProfitabilityIcon(opp.affiliate_profitability_score)} ${opp.affiliate_profitability_score}%` : 'N/A',
        
        revenueRange: opp.estimated_revenue_range,
        monetizationPriority: opp.monetization_priority,
        topMonetizationStream: opp.monetization_streams.length > 0 ? opp.monetization_streams[0].type : 'None',
        selected: opp.selected || false,
        selectable: true,
        
        // Existing fields
        format: opp.format,
        difficulty: opp.difficulty,
        overallScore: Utils.calculateOverallScore(opp),
        isQuickWin: opp.difficulty <= 40 && opp.engagement_potential === 'High',
        isHighValue: Utils.calculateOverallScore(opp) >= 50,
        monetization_score: opp.monetization_score,
        
        // NEW: ADD AFFILIATE FIELDS
        affiliate_profitability_score: opp.affiliate_profitability_score || 0,
        hasAffiliateData: (opp.affiliate_profitability_score || 0) > 0,
        
        isHighMonetization: opp.monetization_score >= 70,
        stableSort: opp.displayRank || (index + 1)
    }));

    return { topicsTableData, opportunitiesTableData };
}
    };

    // Transform the data
    const transformedTrendingTopics = DataTransformer.transformTrendingTopics(trendingTopics);
    const transformedOpportunities = DataTransformer.transformContentOpportunities(contentOpportunities);
    const { topicsTableData, opportunitiesTableData } = DataTransformer.generateTableData(trendingTopics, contentOpportunities);
    
    // ====================================================================
    // ENHANCED OUTPUTS WITH AFFILIATE INTEGRATION
    // ====================================================================
    
    Outputs.success();
    Outputs.loading = false;
    Outputs.error = "";
    Outputs.currentAnalysisId = currentAnalysisId;
    Outputs.loadMode = loadMode;
    Outputs.currentTab = currentTab;
    Outputs.showOverview = currentTab === "overview";
    Outputs.showTopics = currentTab === "topics";
    Outputs.showOpportunities = currentTab === "opportunities";
    Outputs.showMonetization = currentTab === "monetization";
    Outputs.showGeography = currentTab === "geography";
    Outputs.showActionItems = currentTab === "actionItems";
    Outputs.showContentStrategy = currentTab === "contentStrategy";
    Outputs.showAffiliate = currentTab === "affiliate";
    
    if (Outputs.showAffiliate) {
        Outputs.runAffiliateProcess();
    }

    // ====================================================================
    // ENHANCED MONETIZATION OUTPUTS WITH AFFILIATE DATA
    // ====================================================================

    Outputs.MonetizationDashboard = {
        overview: {
            totalEstimatedRevenue: totalEstimatedRevenue,
            avgMonetizationScore: Outputs.MarketTrendSummary.avgMonetizationScore,
            highPotentialItems: [...trendingTopics, ...contentOpportunities].filter(item => item.monetization_score >= 80).length,
            mediumPotentialItems: [...trendingTopics, ...contentOpportunities].filter(item => item.monetization_score >= 60 && item.monetization_score < 80).length,
            lowPotentialItems: [...trendingTopics, ...contentOpportunities].filter(item => item.monetization_score < 60).length,
        },
        revenueBreakdown: {
            topics: trendingTopics.reduce((sum, t) => {
                const maxRevenue = parseInt(t.estimated_revenue_range.split(' - ')[1].replace(/[$,]/g, '')) || 0;
                return sum + maxRevenue;
            }, 0),
            opportunities: contentOpportunities.reduce((sum, o) => {
                const maxRevenue = parseInt(o.estimated_revenue_range.split(' - ')[1].replace(/[$,]/g, '')) || 0;
                return sum + maxRevenue;
            }, 0)
        },
        streamAnalysis: {
            digital_product: [...trendingTopics, ...contentOpportunities]
                .filter(item => (item.monetization_streams || []).some(s => s.type === 'digital_product')).length,
            services: [...trendingTopics, ...contentOpportunities]
                .filter(item => (item.monetization_streams || []).some(s => s.type === 'services')).length,
            lead_generation: [...trendingTopics, ...contentOpportunities]
                .filter(item => (item.monetization_streams || []).some(s => s.type === 'lead_generation')).length
        },
        topMonetizationItems: [...trendingTopics, ...contentOpportunities]
            .sort((a, b) => (b.monetization_score || 0) - (a.monetization_score || 0))
            .slice(0, 5)
            .map(item => ({
                id: item.id,
                title: item.title || item.trend || item.opportunity,
                type: item.viral_potential ? 'topic' : 'opportunity',
                monetization_score: item.monetization_score,
                estimated_revenue_range: item.estimated_revenue_range,
                priority: item.monetization_priority,
                streams: item.monetization_streams.map(s => s.type),
            }))
    };


    Outputs.MonetizationInsights = {
        recommendations: [
            {
                priority: 'high',
                title: 'Focus on High-Monetization Items',
                description: `${Outputs.MonetizationDashboard.overview.highPotentialItems} items have 80+ monetization scores`,
                action: 'Select high-monetization items for immediate implementation'
            },
            {
                priority: 'medium',
                title: 'Diversify Revenue Streams',
                description: 'Multiple monetization streams identified across your content',
            },
            {
                priority: 'low',
                title: 'Long-term Revenue Growth',
                description: 'Consider service offerings for premium pricing',
                action: 'Develop consulting or done-for-you services'
            }
        ],
        quickWins: contentOpportunities
            .filter(o => o.monetization_score >= 70 && o.difficulty <= 40)
            .slice(0, 3)
            .map(o => ({
                title: o.title,
                estimated_revenue: o.estimated_revenue_range,
                timeframe: '2-4 weeks',
                difficulty: 'Low',
            })),
        revenuePotential: {
            immediate: totalEstimatedRevenue * 0.3,
            sixMonth: totalEstimatedRevenue * 0.7,
            annual: totalEstimatedRevenue
        }
    };

    // ====================================================================
    // ENHANCED TABLE COLUMNS WITH AFFILIATE DATA
    // ====================================================================
Outputs.TrendingTopicsTableColumns = [
    { id: 'selected', Label: 'Select', Width: '4%', Field: 'selected', Editable: true, Type: "Boolean" },
    { id: 'rank', Label: '#', Width: '3%', Field: 'rank', Editable: false, Type: "String", Sortable: true },
    { id: 'topic', Label: 'Trending Topic', Width: '15%', Field: 'topic', Sortable: true, Editable: false, Type: "String", Searchable: true },
    { id: 'viralScoreDisplay', Label: 'Viral Potential', Width: '9%', Field: 'viralScoreDisplay', Editable: false, Type: "String", Sortable: true, SortField: 'viralScore' },
    { id: 'monetizationScoreDisplay', Label: 'Monetization', Width: '9%', Field: 'monetizationScoreDisplay', Editable: false, Type: "String", Sortable: true, SortField: 'monetization_score' },
    
    // NEW: ADD AFFILIATE COLUMN
    { id: 'affiliateScoreDisplay', Label: 'Affiliate Score', Width: '9%', Field: 'affiliateScoreDisplay', Editable: false, Type: "String", Sortable: true, SortField: 'affiliate_profitability_score' },
    
    { id: 'revenueRange', Label: 'Revenue Range', Width: '10%', Field: 'revenueRange', Editable: false, Type: "String" },
    { id: 'opportunityLevel', Label: 'Opportunity', Width: '8%', Field: 'opportunityLevel', Editable: false, Type: "String", Sortable: true, SortField: 'opportunityScore' },
    { id: 'searchVolume', Label: 'Search Volume', Width: '8%', Field: 'searchVolume', Editable: false, Type: "String", Filterable: true, FilterOptions: ['All', 'High', 'Medium', 'Low'] },
    { id: 'competition', Label: 'Competition', Width: '7%', Field: 'competition', Editable: false, Type: "String", Filterable: true, FilterOptions: ['All', 'Low', 'Medium', 'High'] },
    { id: 'primaryKeywords', Label: 'Top Keywords', Width: '10%', Editable: false, Type: "String", Field: 'primaryKeywords' }
];

// Same for opportunities table
Outputs.ContentOpportunitiesTableColumns = [
    { id: 'selected', Label: 'Select', Width: '4%', Field: 'selected', Editable: true, Type: "Boolean" },
    { id: 'rank', Label: '#', Width: '3%', Field: 'rank', Sortable: true, Editable: false, Type: "String" },
    { id: 'title', Label: 'Content Opportunity', Width: '18%', Field: 'title', Sortable: true, Searchable: true, Editable: false, Type: "String" },
    { id: 'formatWithIcon', Label: 'Content Type', Width: '9%', Field: 'formatWithIcon', Filterable: true, FilterField: 'format', Editable: false, Type: "String" },
    { id: 'monetizationScoreDisplay', Label: 'Monetization', Width: '9%', Field: 'monetizationScoreDisplay', Editable: false, Type: "String", Sortable: true, SortField: 'monetization_score' },
    
    // NEW: ADD AFFILIATE COLUMN
    { id: 'affiliateScoreDisplay', Label: 'Affiliate Score', Width: '9%', Field: 'affiliateScoreDisplay', Editable: false, Type: "String", Sortable: true, SortField: 'affiliate_profitability_score' },
    
    { id: 'revenueRange', Label: 'Revenue Range', Width: '10%', Field: 'revenueRange', Editable: false, Type: "String" },
    { id: 'engagementPotential', Label: 'Engagement', Width: '8%', Field: 'engagementPotential', Filterable: true, FilterOptions: ['All', 'High', 'Medium', 'Low'], Editable: false, Type: "String" },
    { id: 'difficultyDisplay', Label: 'Difficulty', Width: '9%', Field: 'difficultyDisplay', Sortable: true, SortField: 'difficulty', Editable: false, Type: "String" },
    { id: 'timeInvestment', Label: 'Time Investment', Width: '9%', Field: 'timeInvestment', Filterable: true, FilterOptions: ['All', '1-2 weeks', '2-3 weeks', '3-4 weeks', '1+ month'], Editable: false, Type: "String" }
];

    // ====================================================================
    // ENHANCED FILTERS WITH AFFILIATE OPTIONS
    // ====================================================================
// FIX: Add affiliate filter to TopicsFilters and OpportunitiesFilters
Outputs.TopicsFilters = {
    viralPotential: {
        label: 'Viral Potential',
        options: ['All', 'High (80+)', 'Medium (60-79)', 'Low (<60)'],
        current: enhancedFilterSettings.viralPotential || 'All'
    },
    monetizationScore: {
        label: 'Monetization Score',
        options: ['All', 'High (70+)', 'Medium (50-69)', 'Low (<50)'],
        current: enhancedFilterSettings.monetizationScore || 'All'
    },
    
    // NEW: ADD AFFILIATE FILTER
    affiliateScore: {
        label: 'Affiliate Score',
        options: ['All', 'Excellent (70+)', 'Good (50-69)', 'Moderate (30-49)', 'Poor (<30)', 'No Data'],
        current: enhancedFilterSettings.affiliateScore || 'All'
    },
    
    searchVolume: {
        label: 'Search Volume',
        options: ['All', 'High', 'Medium', 'Low'],
        current: enhancedFilterSettings.searchVolume || 'All'
    },
    competition: {
        label: 'Competition',
        options: ['All', 'Low', 'Medium', 'High'],
        current: enhancedFilterSettings.competition || 'All'
    },
    selected: {
        label: 'Selection Status',
        options: ['All', 'Selected', 'Not Selected'],
        current: enhancedFilterSettings.selected || 'All'
    },
    quickFilters: [
        { id: 'all', label: 'All Topics', count: trendingTopics.length, active: !enhancedFilterSettings.quickFilter || enhancedFilterSettings.quickFilter === 'all' },
        { id: 'highPotential', label: 'High Potential (80+)', count: trendingTopics.filter(t => t.viral_potential >= 80).length, active: enhancedFilterSettings.quickFilter === 'highPotential' },
        { id: 'highMonetization', label: 'High Monetization (70+)', count: trendingTopics.filter(t => (t.monetization_score || 0) >= 70).length, active: enhancedFilterSettings.quickFilter === 'highMonetization' },
        
        // NEW: ADD AFFILIATE QUICK FILTERS
        { id: 'highAffiliate', label: 'High Affiliate (70+)', count: trendingTopics.filter(t => (t.affiliate_profitability_score || 0) >= 70).length, active: enhancedFilterSettings.quickFilter === 'highAffiliate' },
        { id: 'affiliateReady', label: 'Affiliate Ready', count: trendingTopics.filter(t => (t.affiliate_profitability_score || 0) >= 50).length, active: enhancedFilterSettings.quickFilter === 'affiliateReady' },
        { id: 'noAffiliateData', label: 'No Affiliate Data', count: trendingTopics.filter(t => (t.affiliate_profitability_score || 0) === 0).length, active: enhancedFilterSettings.quickFilter === 'noAffiliateData' },
        
        { id: 'quickWins', label: 'Quick Wins', count: trendingTopics.filter(t => t.viral_potential >= 60 && t.competition === 'Low').length, active: enhancedFilterSettings.quickFilter === 'quickWins' },
        { id: 'selected', label: 'Selected', count: trendingTopics.filter(t => t.selected).length, active: enhancedFilterSettings.quickFilter === 'selected' }
    ]
};

    // Enhanced Opportunities Filters with Affiliate Support
    Outputs.OpportunitiesFilters = {
        format: {
            label: 'Content Format',
            options: ['All', 'Blog Post', 'Video', 'Podcast', 'Course', 'Guide', 'Checklist', 'Template'],
            current: filterSettings.format || 'All'
        },
        engagement: {
            label: 'Engagement Potential',
            options: ['All', 'High', 'Medium', 'Low'],
            current: filterSettings.engagement || 'All'
        },
        monetizationScore: {
            label: 'Monetization Score',
            options: ['All', 'High (70+)', 'Medium (50-69)', 'Low (<50)'],
            current: filterSettings.monetizationScore || 'All'
        },
        difficulty: {
            label: 'Difficulty Level',
            options: ['All', 'Beginner', 'Intermediate', 'Advanced', 'Expert'],
            current: filterSettings.difficulty || 'All'
        },
        timeInvestment: {
            label: 'Time Investment',
            options: ['All', '1-2 weeks', '2-3 weeks', '3-4 weeks', '1+ month'],
            current: filterSettings.timeInvestment || 'All'
        },
        selected: {
            label: 'Selection Status',
            options: ['All', 'Selected', 'Not Selected'],
            current: filterSettings.selected || 'All'
        },
        quickFilters: [
            { id: 'all', label: 'All Opportunities', count: contentOpportunities.length, active: !filterSettings.quickFilter || filterSettings.quickFilter === 'all' },
            { id: 'quickWins', label: 'Quick Wins', count: contentOpportunities.filter(o => o.difficulty <= 40 && o.engagement_potential === 'High').length, active: filterSettings.quickFilter === 'quickWins' },
            { id: 'highValue', label: 'High Value (50+)', count: contentOpportunities.filter(o => (o.overallScore || 0) >= 50).length, active: filterSettings.quickFilter === 'highValue' },
            { id: 'highMonetization', label: 'High Monetization (70+)', count: contentOpportunities.filter(o => (o.monetization_score || 0) >= 70).length, active: filterSettings.quickFilter === 'highMonetization' },
            { id: 'selected', label: 'Selected', count: contentOpportunities.filter(o => o.selected).length, active: filterSettings.quickFilter === 'selected' }
        ]
    };

    // Quick Filters for Topics
    Outputs.topicQuickFilters = [
        { id: 'all', label: 'All Topics', count: trendingTopics.length, active: !filterSettings.quickFilter || filterSettings.quickFilter === 'all' },
        { id: 'highPotential', label: 'High Potential (80+)', count: trendingTopics.filter(t => t.viral_potential >= 80).length, active: filterSettings.quickFilter === 'highPotential' },
        { id: 'highMonetization', label: 'High Monetization (70+)', count: trendingTopics.filter(t => (t.monetization_score || 0) >= 70).length, active: filterSettings.quickFilter === 'highMonetization' },
        { id: 'quickWins', label: 'Quick Wins', count: trendingTopics.filter(t => t.viral_potential >= 60 && t.competition === 'Low').length, active: filterSettings.quickFilter === 'quickWins' },
        { id: 'selected', label: 'Selected', count: trendingTopics.filter(t => t.selected).length, active: filterSettings.quickFilter === 'selected' }
    ];

    // Quick Filters for Opportunities
    Outputs.opportunityQuickFilters = [
        { id: 'all', label: 'All Opportunities', count: contentOpportunities.length, active: !filterSettings.quickFilter || filterSettings.quickFilter === 'all' },
        { id: 'quickWins', label: 'Quick Wins', count: contentOpportunities.filter(o => o.difficulty <= 40 && o.engagement_potential === 'High').length, active: filterSettings.quickFilter === 'quickWins' },
        { id: 'highValue', label: 'High Value (50+)', count: contentOpportunities.filter(o => (o.overallScore || 0) >= 50).length, active: filterSettings.quickFilter === 'highValue' },
        { id: 'highMonetization', label: 'High Monetization (70+)', count: contentOpportunities.filter(o => (o.monetization_score || 0) >= 70).length, active: filterSettings.quickFilter === 'highMonetization' },
        { id: 'selected', label: 'Selected', count: contentOpportunities.filter(o => o.selected).length, active: filterSettings.quickFilter === 'selected' }
    ]

    // Enhanced Tab Navigation with Affiliate Tab
    Outputs.TabNavigation = {
        currentTab: currentTab,
        tabs: [
            { id: 'overview', label: 'Overview', badge: '', active: currentTab === 'overview', icon: '📊' },
            { id: 'topics', label: 'Topics', badge: trendingTopics.filter(t => t.selected).length > 0 ? `(${trendingTopics.filter(t => t.selected).length}/${trendingTopics.length})` : `(${trendingTopics.length})`, active: currentTab === 'topics', icon: '📈' },
            { id: 'opportunities', label: 'Opportunities', badge: contentOpportunities.filter(o => o.selected).length > 0 ? `(${contentOpportunities.filter(o => o.selected).length}/${contentOpportunities.length})` : `(${contentOpportunities.length})`, active: currentTab === 'opportunities', icon: '💡' },
            { id: 'monetization', label: 'Monetization', badge: `${Math.round(totalEstimatedRevenue / 1000)}K`, active: currentTab === 'monetization', icon: '💵' },
            { id: 'geography', label: 'Geography', badge: '', active: currentTab === 'geography', icon: '🌍' },
            { id: 'actionItems', label: 'Action Items', badge: '', active: currentTab === 'actionItems', icon: '✅' },
            { id: 'contentStrategy', label: 'Content Strategy', badge: '', active: currentTab === 'contentStrategy', icon: '📋' },
            { id: 'affiliate', label: 'Affiliate', badge: '', active: currentTab === 'affiliate', icon: '💰' }
        ]
    };

    // ====================================================================
    // ENHANCED QUICK ACTIONS WITH AFFILIATE-AWARE SELECTIONS
    // ====================================================================
    
    Outputs.QuickActions = {
        smartSelect: {
            enabled: trendingTopics.length > 0 || contentOpportunities.length > 0,
            label: 'Smart Selection',
            description: 'Auto-select top 3 viral topics + 2 high-monetization opportunities',
            icon: '🎯',
            count: Math.min(3, trendingTopics.length) + Math.min(2, contentOpportunities.filter(o => (o.monetization_score || 0) >= 60).length)
        },
        selectHighPotential: {
            enabled: trendingTopics.filter(t => t.viral_potential >= 70).length > 0,
            label: 'High Potential Only',
            description: 'Select topics with 70+ viral score',
            icon: '🔥',
            count: trendingTopics.filter(t => t.viral_potential >= 70).length
        },
        selectQuickWins: {
            enabled: contentOpportunities.filter(o => o.difficulty <= 40 && o.engagement_potential === 'High').length > 0,
            label: 'Quick Wins',
            description: 'Select low-difficulty, high-engagement opportunities',
            icon: '⚡',
            count: contentOpportunities.filter(o => o.difficulty <= 40 && o.engagement_potential === 'High').length
        },
        selectHighMonetization: {
            enabled: [...trendingTopics, ...contentOpportunities].filter(item => (item.monetization_score || 0) >= 70).length > 0,
            label: 'High Monetization',
            description: 'Select items with 70+ total monetization score',
            icon: '💵',
            count: [...trendingTopics, ...contentOpportunities].filter(item => (item.monetization_score || 0) >= 70).length
        },
        selectRevenueFocused: {
            enabled: [...trendingTopics, ...contentOpportunities].length > 0,
            label: 'Revenue Focused',
            description: 'Select top 5 highest revenue potential items',
            icon: '💎',
            count: Math.min(5, [...trendingTopics, ...contentOpportunities].length)
        },
        selectAllTopics: {
            enabled: trendingTopics.length > 0,
            label: 'All Topics',
            description: `Select all ${trendingTopics.length} trending topics`,
            icon: '📈',
            count: trendingTopics.length
        },
        selectAllOpportunities: {
            enabled: contentOpportunities.length > 0,
            label: 'All Opportunities',
            description: `Select all ${contentOpportunities.length} content opportunities`,
            icon: '💡',
            count: contentOpportunities.length
        },
        clearAll: {
            enabled: (trendingTopics.filter(t => t.selected).length + contentOpportunities.filter(o => o.selected).length) > 0,
            label: 'Clear All',
            description: 'Remove all selections',
            icon: '🗑️',
            count: trendingTopics.filter(t => t.selected).length + contentOpportunities.filter(o => o.selected).length
        }
    };

    // ====================================================================
    // ENHANCED PYTRENDS OUTPUTS (EXISTING LOGIC)
    // ====================================================================

    if (pytrendsAvailable) {
        const urgentActions = actionableInsights.filter(insight => insight.priority === 'high');
        const timingSuggestions = actionableInsights.filter(insight => insight.type === 'timing');
        const geographicOpportunities = actionableInsights.filter(insight => 
            insight.type === 'targeting' || insight.type === 'geographic'
        );
        
        Outputs.PyTrendsInsights = {
            available: true,
            mainTopicAnalysis: {
                currentInterest,
                trendDirection,
                momentum,
                peakInterest,
                recommendation,
                growthPotential
            },
            geographicHotspots,
            seasonalPatterns: {
                hasPattern: seasonalPatterns.has_seasonal_pattern || false,
                peakMonths: seasonalPatterns.peak_months || [],
                nextPeak: seasonalPatterns.next_peak_prediction || null
            },
            relatedQueries: {
                topQueries: relatedQueries.top_related_queries || [],
                risingQueries: relatedQueries.rising_queries || []
            },
            actionableInsights
        };
        
        Outputs.GoogleTrendsOverview = {
            available: true,
            currentScore: currentInterest,
            trendDirection,
            momentum,
            topMarket: geographicHotspots.length > 0 ? geographicHotspots[0].country : "Unknown",
            nextPeakTiming: seasonalPatterns.next_peak_prediction ? seasonalPatterns.next_peak_prediction.month : null,
            hasData: true,
            growthPotential
        };
        
        Outputs.ActionableInsightsPanel = {
            urgentActions,
            timingSuggestions,
            geographicOpportunities,
            hasUrgentActions: urgentActions.length > 0,
            available: true
        };
        
    } else {
        // Empty PyTrends structure (fallback)
        Outputs.PyTrendsInsights = {
            available: false,
            mainTopicAnalysis: {
                currentInterest: 0,
                trendDirection: "unknown",
                momentum: 0,
                peakInterest: 0,
                recommendation: "PyTrends data not available"
            },
            geographicHotspots: [],
            seasonalPatterns: { hasPattern: false, peakMonths: [], nextPeak: null },
            relatedQueries: { topQueries: [], risingQueries: [] },
            actionableInsights: []
        };
        
        Outputs.GoogleTrendsOverview = {
            available: false,
            currentScore: 0,
            trendDirection: "unknown",
            momentum: 0,
            topMarket: "Unknown",
            nextPeakTiming: null,
            hasData: false
        };
        
        Outputs.ActionableInsightsPanel = {
            urgentActions: [],
            timingSuggestions: [],
            geographicOpportunities: [],
            hasUrgentActions: false,
            available: false
        };
    }

    // ====================================================================
    // ENHANCED RAW DATA OUTPUTS
    // ====================================================================
    
    Outputs.TrendingTopicsList = transformedTrendingTopics;
    Outputs.ContentOpportunitiesList = transformedOpportunities;

    const transformedKeywordIntelligence = {
        high_volume_keywords: keywordIntelligence.high_volume_keywords || [],
        low_competition_keywords: keywordIntelligence.low_competition_keywords || [],
        emerging_keywords: keywordIntelligence.emerging_keywords || [],
        keyword_clusters: Utils.safeGet(keywordIntelligence, 'additional_data.keyword_clusters', {})
    };

    Outputs.SEOIntelligence = transformedKeywordIntelligence;
    Outputs.HighVolumeKeywords = transformedKeywordIntelligence.high_volume_keywords;
    Outputs.LowCompetitionKeywords = transformedKeywordIntelligence.low_competition_keywords;
    Outputs.EmergingKeywords = transformedKeywordIntelligence.emerging_keywords;
    Outputs.KeywordClusters = transformedKeywordIntelligence.keyword_clusters;

    // Enhanced Competitive Analysis with Affiliate Data
    const mockCompetitiveGaps = {
        analysis: "Comprehensive competitive analysis with monetization focus.",
        weaknesses: [
            "Most content lacks clear monetization strategy"
        ],
        niches: [
            `${analysisInfo.topic} monetization strategies`,
            `Revenue-generating ${analysisInfo.topic} content`
        ]
    };

    Outputs.CompetitiveAnalysis = mockCompetitiveGaps;
    Outputs.ContentGaps = [mockCompetitiveGaps.analysis];
    Outputs.CompetitorWeaknesses = mockCompetitiveGaps.weaknesses;
    Outputs.UntappedNiches = mockCompetitiveGaps.niches;

    // ====================================================================
    // ENHANCED FILTERING AND PROCESSING WITH AFFILIATE SUPPORT
    // ====================================================================

    // Enhanced filter processing function
 const processQuickFilters = (filterType, filterValue, targetTable) => {
    console.log(`🎯 Processing quick filter: ${filterType}=${filterValue} for ${targetTable}`);
    
    const quickFilterMap = {
        topics: {
            all: () => ({}),
            highPotential: () => ({ viralPotential: 'High (80+)' }),
            highMonetization: () => ({ monetizationScore: 'High (70+)' }),
            
            // NEW: ADD AFFILIATE FILTER MAPPINGS
            highAffiliate: () => ({ affiliateScore: 'Excellent (70+)' }),
            affiliateReady: () => ({ affiliateScore: 'Good (50+)' }),
            noAffiliateData: () => ({ affiliateScore: 'No Data' }),
            
            quickWins: () => ({ viralPotential: 'Medium (60-79)', competition: 'Low' }),
            selected: () => ({ selected: 'Selected' })
        },
        opportunities: {
            all: () => ({}),
            quickWins: () => ({ difficulty: 'Beginner', engagement: 'High' }),
            highValue: () => ({ engagement: 'High' }),
            highMonetization: () => ({ monetizationScore: 'High (70+)' }),
            
            // NEW: ADD AFFILIATE FILTER MAPPINGS
            highAffiliate: () => ({ affiliateScore: 'Excellent (70+)' }),
            affiliateReady: () => ({ affiliateScore: 'Good (50+)' }),
            
            selected: () => ({ selected: 'Selected' })
        }
    };

    return quickFilterMap[targetTable]?.[filterValue]?.() || {};
};

    // Handle quick filter inputs from buttons
    let enhancedFilterSettings = { ...filterSettings };
    
    // Check for quick filter inputs
    if (Inputs.filterType === 'quickFilter' && Inputs.filterValue && Inputs.targetTable) {
        const quickFilterSettings = processQuickFilters(
            Inputs.filterType,
            Inputs.filterValue,
            Inputs.targetTable
        );
        enhancedFilterSettings = { ...enhancedFilterSettings, ...quickFilterSettings, quickFilter: Inputs.filterValue };
        console.log(`✅ Applied quick filter:`, quickFilterSettings);
    }

    // Enhanced Filter Processing Function with Affiliate Support
 const applyFilters = (data, filters, type) => {
    if (!Array.isArray(data)) {
        console.warn('⚠️ applyFilters: data is not an array, returning empty array');
        return [];
    }
    
    let filteredData = [...data];
    
    if (type === 'topics' || type === 'opportunities') {
        // Existing filters...
        if (filters.viralPotential && filters.viralPotential !== 'All') {
            const match = filters.viralPotential.match(/(\d+)/);
            const minScore = match ? parseInt(match[1]) : 0;
            filteredData = filteredData.filter(t => (t.viral_potential || 0) >= minScore);
        }
        if (filters.monetizationScore && filters.monetizationScore !== 'All') {
            const match = filters.monetizationScore.match(/(\d+)/);
            const minScore = match ? parseInt(match[1]) : 0;
            filteredData = filteredData.filter(t => (t.monetization_score || 0) >= minScore);
        }
            if (filters.searchVolume && filters.searchVolume !== 'All') {
                filteredData = filteredData.filter(t => t.search_volume === filters.searchVolume);
            }
            if (filters.competition && filters.competition !== 'All') {
                filteredData = filteredData.filter(t => t.competition === filters.competition);
            }
            if (filters.selected && filters.selected !== 'All') {
                const selectedOnly = filters.selected === 'Selected';
                filteredData = filteredData.filter(t => t.selected === selectedOnly);
            }
        } else if (type === 'opportunities') {
            if (filters.format && filters.format !== 'All') {
                const formatKey = filters.format.toLowerCase().replace(/ /g, '_');
                filteredData = filteredData.filter(o => o.format === formatKey);
            }
            if (filters.engagement && filters.engagement !== 'All') {
                filteredData = filteredData.filter(o => o.engagement_potential === filters.engagement);
            }
            if (filters.monetizationScore && filters.monetizationScore !== 'All') {
                const match = filters.monetizationScore.match(/(\d+)/);
                const minScore = match ? parseInt(match[1]) : 0;
                filteredData = filteredData.filter(o => (o.monetization_score || 0) >= minScore);
            }
            if (filters.difficulty && filters.difficulty !== 'All') {
                const difficultyMap = {
                    'Beginner': [0, 40],
                    'Intermediate': [41, 60],
                    'Advanced': [61, 80],
                    'Expert': [81, 100]
                };
                const [min, max] = difficultyMap[filters.difficulty] || [0, 100];
                filteredData = filteredData.filter(o => (o.difficulty || 0) >= min && (o.difficulty || 0) <= max);
            }
            if (filters.timeInvestment && filters.timeInvestment !== 'All') {
                filteredData = filteredData.filter(o => 
                    Utils.safeGet(o, 'additional_data.time_investment', "2-3 weeks") === filters.timeInvestment
                );
            }
            if (filters.selected && filters.selected !== 'All') {
                const selectedOnly = filters.selected === 'Selected';
                filteredData = filteredData.filter(o => o.selected === selectedOnly);
            }
                   if (filters.affiliateScore && filters.affiliateScore !== 'All') {
            if (filters.affiliateScore === 'No Data') {
                filteredData = filteredData.filter(item => (item.affiliate_profitability_score || 0) === 0);
            } else {
                const match = filters.affiliateScore.match(/(\d+)/);
                const minScore = match ? parseInt(match[1]) : 0;
                filteredData = filteredData.filter(item => (item.affiliate_profitability_score || 0) >= minScore);
            }
        }
        

        if (filters.searchVolume && filters.searchVolume !== 'All') {
            filteredData = filteredData.filter(t => t.search_volume === filters.searchVolume);
        }
        if (filters.competition && filters.competition !== 'All') {
            filteredData = filteredData.filter(t => t.competition === filters.competition);
        }
        if (filters.selected && filters.selected !== 'All') {
            const selectedOnly = filters.selected === 'Selected';
            filteredData = filteredData.filter(t => t.selected === selectedOnly);
        }
    }
    
    return filteredData;
};
        }
        
        return filteredData;
    };



    // Apply filters to actual data outputs
    const filteredTopics = applyFilters(transformedTrendingTopics, enhancedFilterSettings, 'topics');
    const filteredOpportunities = applyFilters(transformedOpportunities, enhancedFilterSettings, 'opportunities');
    
    // Update outputs with filtered data
    Outputs.TrendingTopicsTableData = DataTransformer.generateTableData(
        filteredTopics.map(t => trendingTopics.find(original => original.id === t.id)), 
        filteredOpportunities.map(o => contentOpportunities.find(original => original.id === o.id))
    ).topicsTableData;
    
    Outputs.ContentOpportunitiesTableData = DataTransformer.generateTableData(
        filteredTopics.map(t => trendingTopics.find(original => original.id === t.id)), 
        filteredOpportunities.map(o => contentOpportunities.find(original => original.id === o.id))
    ).opportunitiesTableData;

    // Update quick filters to reflect active filter
    const updateQuickFilters = (quickFilters, activeFilter) => {
        return quickFilters.map(filter => ({
            ...filter,
            active: filter.id === activeFilter
        }));
    };

    Outputs.topicQuickFilters = updateQuickFilters(Outputs.topicQuickFilters, enhancedFilterSettings.quickFilter);
    Outputs.opportunityQuickFilters = updateQuickFilters(Outputs.opportunityQuickFilters, enhancedFilterSettings.quickFilter);

    // Update overview metrics with filtered data
    if (currentTab === "overview") {
        Outputs.OverviewMetrics = {
            totalTopics: trendingTopics.length,
            totalOpportunities: contentOpportunities.length,
            filteredTopics: filteredTopics.length,
            filteredOpportunities: filteredOpportunities.length,
            selectedTopics: trendingTopics.filter(t => t.selected).length,
            selectedOpportunities: contentOpportunities.filter(o => o.selected).length,
            confidenceScore: Utils.safeGet(analysisInfo, 'metadata.confidence_score', 85),
            readyForPhase2: (trendingTopics.filter(t => t.selected).length > 0 || contentOpportunities.filter(o => o.selected).length > 0),
            selectionProgress: Math.round(((trendingTopics.filter(t => t.selected).length + contentOpportunities.filter(o => o.selected).length) / Math.max(trendingTopics.length + contentOpportunities.length, 1)) * 100),
            topicSelectionRate: Math.round((trendingTopics.filter(t => t.selected).length / Math.max(trendingTopics.length, 1)) * 100),
            opportunitySelectionRate: Math.round((contentOpportunities.filter(o => o.selected).length / Math.max(contentOpportunities.length, 1)) * 100),
            totalEstimatedRevenue: totalEstimatedRevenue,
            avgMonetizationScore: Outputs.MarketTrendSummary.avgMonetizationScore,
            highMonetizationItems: [...trendingTopics, ...contentOpportunities].filter(item => (item.monetization_score || 0) >= 70).length,
            selectedMonetizationPotential: [...trendingTopics.filter(t => t.selected), ...contentOpportunities.filter(o => o.selected)]
                .reduce((sum, item) => {
                    const maxRevenue = parseInt(item.estimated_revenue_range.split(' - ')[1].replace(/[$,]/g, '')) || 0;
                    return sum + maxRevenue;
                }, 0),
            filterApplied: enhancedFilterSettings.quickFilter || Object.keys(enhancedFilterSettings).some(key => 
                key !== 'quickFilter' && enhancedFilterSettings[key] !== 'All' && enhancedFilterSettings[key]
            ),
            activeFilters: Object.keys(enhancedFilterSettings).filter(key => 
                enhancedFilterSettings[key] && enhancedFilterSettings[key] !== 'All'
            ).length
        };

        Outputs.TopTrendingTopics = filteredTopics
            .sort((a, b) => b.viral_potential - a.viral_potential)
            .slice(0, 3)
            .map(topic => ({
                title: topic.trend,
                viralScore: topic.viral_potential,
                viralScoreColor: Utils.getViralScoreColor(topic.viral_potential),
                viralScoreIcon: Utils.getViralScoreIcon(topic.viral_potential),
                keywordsPreview: topic.keywords.slice(0, 3).join(', '),
                selected: topic.selected,
                id: topic.id,
                monetizationScore: topic.monetization_score,
                monetizationIcon: topic.monetizationIcon,
                monetizationColor: topic.monetizationColor,
                revenueRange: topic.estimated_revenue_range,
            }));

        Outputs.TopOpportunities = filteredOpportunities
            .sort((a, b) => b.overallScore - a.overallScore)
            .slice(0, 3)
            .map(opp => ({
                title: opp.opportunity,
                format: opp.format.replace(/_/g, ' ').toUpperCase(),
                formatIcon: Utils.getContentFormatIcon(opp.format),
                engagementPotential: opp.engagement_potential,
                difficultyLevel: Utils.getDifficultyLevel(opp.difficulty),
                difficultyColor: Utils.getDifficultyColor(opp.difficulty),
                selected: opp.selected,
                id: opp.id,
                monetizationScore: opp.monetization_score,
                monetizationIcon: opp.monetizationIcon,
                monetizationColor: opp.monetizationColor,
                revenueRange: opp.estimated_revenue_range,
            }));

        // Enhanced Top Monetization Opportunities
        Outputs.TopMonetizationOpportunities = [...filteredTopics, ...filteredOpportunities]
            .sort((a, b) => (b.monetization_score || 0) - (a.monetization_score || 0))
            .slice(0, 3)
            .map(item => ({
                title: item.trend || item.opportunity,
                type: item.trend ? 'topic' : 'opportunity',
                monetizationScore: item.monetization_score,
                monetizationIcon: item.monetizationIcon,
                monetizationColor: item.monetizationColor,
                revenueRange: item.estimated_revenue_range,
                priority: item.monetization_priority,
                topStream: item.monetization_streams.length > 0 ? item.monetization_streams[0].type : 'None',
                selected: item.selected,
                id: item.id,
            }));
    }

    // ====================================================================
    // ENHANCED SELECTION MANAGEMENT OUTPUTS WITH AFFILIATE SUPPORT
    // ====================================================================
    
    Outputs.SelectedTopicIds = trendingTopics.filter(t => t.selected).map(t => t.id);
    Outputs.SelectedOpportunityIds = contentOpportunities.filter(o => o.selected).map(o => o.id);
    
    const selectedTopicsCount = trendingTopics.filter(t => t.selected).length;
    const selectedOpportunitiesCount = contentOpportunities.filter(o => o.selected).length;
    const totalSelections = selectedTopicsCount + selectedOpportunitiesCount;
    
    // Enhanced Selection Summary with Affiliate Data
    const selectedItems = [...trendingTopics.filter(t => t.selected), ...contentOpportunities.filter(o => o.selected)];
    const selectedMonetizationPotential = selectedItems.reduce((sum, item) => {
        const maxRevenue = parseInt(item.estimated_revenue_range?.split(' - ')[1]?.replace(/[$,]/g, '') || '0') || 0;
        return sum + maxRevenue;
    }, 0);
    
    Outputs.SelectionSummary = {
        selectedTopics: selectedTopicsCount,
        totalTopics: trendingTopics.length,
        selectedOpportunities: selectedOpportunitiesCount,
        totalOpportunities: contentOpportunities.length,
        readyForPhase2: totalSelections > 0,
        totalSelections,
        selectionProgress: Math.round((totalSelections / Math.max(trendingTopics.length + contentOpportunities.length, 1)) * 100),
        hasHighPotentialSelections: trendingTopics.some(t => t.selected && t.viral_potential >= 80) || contentOpportunities.some(o => o.selected && o.engagement_potential === 'High'),
        selectedMonetizationPotential: selectedMonetizationPotential,
        avgSelectedMonetizationScore: selectedItems.length > 0 ? Math.round(selectedItems.reduce((sum, item) => sum + (item.monetization_score || 0), 0) / selectedItems.length) : 0,
        hasHighMonetizationSelections: selectedItems.some(item => (item.monetization_score || 0) >= 70),
        topSelectedMonetizationStream: selectedItems.length > 0 ? 
            selectedItems.reduce((acc, item) => {
                (item.monetization_streams || []).forEach(stream => {
                    acc[stream.type] = (acc[stream.type] || 0) + 1;
                });
                return acc;
            }, {}) : {},
    };

    // ====================================================================
    // ENHANCED PHASE 2 READINESS WITH AFFILIATE ASSESSMENT
    // ====================================================================
    
    const generatePhase2Recommendations = () => {
        const recommendations = [];
        
        if (totalSelections === 0) {
            recommendations.push({ type: 'warning', message: 'Select at least 1 topic or opportunity to proceed to Phase 2', action: 'selectItems', priority: 'high' });
        } else if (totalSelections > 10) {
            recommendations.push({ type: 'info', message: 'Consider reducing selections to 5-8 items for focused blog idea generation', action: 'optimizeSelection', priority: 'medium' });
        }
        
        if (!Outputs.SelectionSummary.hasHighPotentialSelections) {
            recommendations.push({ type: 'suggestion', message: 'Consider adding at least one high-potential item for better blog ideas', action: 'addHighPotential', priority: 'medium' });
        }
        
        // Enhanced monetization recommendations
        if (!Outputs.SelectionSummary.hasHighMonetizationSelections) {
            recommendations.push({ type: 'suggestion', message: 'Add high-monetization items for better revenue potential', action: 'addHighMonetization', priority: 'medium' });
        }
        
        if (selectedTopicsCount > 0 && selectedOpportunitiesCount === 0) {
            recommendations.push({ type: 'suggestion', message: 'Add content opportunities for more diverse blog idea formats', action: 'addOpportunities', priority: 'low' });
        }
        
        if (selectedOpportunitiesCount > 0 && selectedTopicsCount === 0) {
            recommendations.push({ type: 'suggestion', message: 'Add trending topics for more timely and viral blog ideas', action: 'addTopics', priority: 'low' });
        }
        
        return recommendations;
    };

    Outputs.Phase2Readiness = {
        isReady: Outputs.SelectionSummary.readyForPhase2,
        analysisId: currentAnalysisId,
        selectedItemsCount: totalSelections,
        meetsMinimum: totalSelections >= 1,
        hasHighQuality: Outputs.SelectionSummary.hasHighPotentialSelections,
        isOptimal: totalSelections >= 3 && totalSelections <= 8,
        recommendations: generatePhase2Recommendations(),
        hasMonetizationPotential: Outputs.SelectionSummary.hasHighMonetizationSelections,
        estimatedRevenuePotential: selectedMonetizationPotential,
        avgMonetizationScore: Outputs.SelectionSummary.avgSelectedMonetizationScore,
        phase2Preview: {
            trendAnalysisId: currentAnalysisId,
            researchContext: {
                topic: analysisInfo.topic,
                targetAudience: analysisInfo.target_audience,
                focusArea: analysisInfo.focus_area,
                confidenceScore: Utils.safeGet(analysisInfo, 'metadata.confidence_score', 85)
            },
            selectionSummary: Outputs.SelectionSummary,
            selectedTopicsCount,
            selectedOpportunitiesCount,
            confidenceLevel: Utils.safeGet(analysisInfo, 'metadata.confidence_score', 85) >= 80 ? 'High' : 
                           Utils.safeGet(analysisInfo, 'metadata.confidence_score', 85) >= 60 ? 'Medium' : 'Low',
            monetizationPreview: {
                totalRevenuePotential: selectedMonetizationPotential,
                avgMonetizationScore: Outputs.SelectionSummary.avgSelectedMonetizationScore,
                topMonetizationStreams: Object.keys(Outputs.SelectionSummary.topSelectedMonetizationStream || {}).slice(0, 3),
                revenueCategory: selectedMonetizationPotential >= 10000 ? 'High' : selectedMonetizationPotential >= 5000 ? 'Medium' : 'Low'
            }
        }
    };

    // ====================================================================
    // ENHANCED UI STATE AND ADDITIONAL OUTPUTS
    // ====================================================================
    
    Outputs.UIState = {
        hasData: trendingTopics.length > 0 || contentOpportunities.length > 0,
        isEmpty: trendingTopics.length === 0 && contentOpportunities.length === 0,
        hasSelections: totalSelections > 0,
        isLoadingSelection: false,
        isLoadingData: false,
        hasError: false,
        errorMessage: '',
        showSuccessMessage: Outputs.selectionSuccess || Outputs.bulkSelectionSuccess || false,
        successMessage: Outputs.selectionSuccess ? 'Selection updated successfully' : Outputs.bulkSelectionSuccess ? 'Bulk selection completed' : '',
        lastDataUpdate: Date.now(),
        lastSelectionUpdate: Outputs.lastSelectionUpdate || Date.now(),
        hasMonetizationData: [...trendingTopics, ...contentOpportunities].some(item => item.monetization_score > 0),
        showMonetizationInsights: totalEstimatedRevenue > 0,
    };

    // Enhanced Export Data with Affiliate Information
    Outputs.ExportData = {
        analysisId: currentAnalysisId,
        timestamp: new Date().toISOString(),
        summary: {
            topic: analysisInfo.topic,
            focusArea: analysisInfo.focus_area,
            targetAudience: analysisInfo.target_audience,
            confidenceScore: Utils.safeGet(analysisInfo, 'metadata.confidence_score', 85),
            totalTopics: trendingTopics.length,
            totalOpportunities: contentOpportunities.length,
            selectedItems: totalSelections,
            totalEstimatedRevenue: totalEstimatedRevenue,
            avgMonetizationScore: Outputs.MarketTrendSummary.avgMonetizationScore,
            selectedRevenuePotential: selectedMonetizationPotential
        },
        selectedTopics: trendingTopics.filter(t => t.selected).map(t => ({
            title: t.title,
            viralPotential: t.viral_potential,
            keywords: t.keywords,
            searchVolume: t.search_volume,
            competition: t.competition,
            monetizationScore: t.monetization_score,
            revenueRange: t.estimated_revenue_range,
            monetizationPriority: t.monetization_priority,
            monetizationStreams: t.monetization_streams,
        })),
        selectedOpportunities: contentOpportunities.filter(o => o.selected).map(o => ({
            title: o.title,
            format: o.format,
            engagementPotential: o.engagement_potential,
            difficulty: o.difficulty,
            timeInvestment: Utils.safeGet(o, 'additional_data.time_investment', "2-3 weeks"),
            monetizationScore: o.monetization_score,
            revenueRange: o.estimated_revenue_range,
            monetizationPriority: o.monetization_priority,
            monetizationStreams: o.monetization_streams,
        }))
    };

    Outputs.AnalysisMetrics = {
        confidenceScore: Utils.safeGet(analysisInfo, 'metadata.confidence_score', 85),
        enhancedResearch: true,
        dataSource: "supabase",
        analysisId: currentAnalysisId,
        totalTrendingTopics: trendingTopics.length,
        totalOpportunities: contentOpportunities.length,
        selectedItems: totalSelections,
        averageViralScore: trendingTopics.length > 0 ? Math.round(trendingTopics.reduce((sum, t) => sum + t.viral_potential, 0) / trendingTopics.length) : 0,
        highPotentialCount: trendingTopics.filter(t => t.viral_potential >= 80).length,
        quickWinCount: contentOpportunities.filter(o => o.difficulty <= 40 && o.engagement_potential === 'High').length,
        totalEstimatedRevenue: totalEstimatedRevenue,
        avgMonetizationScore: Outputs.MarketTrendSummary.avgMonetizationScore,
        highMonetizationCount: [...trendingTopics, ...contentOpportunities].filter(item => (item.monetization_score || 0) >= 70).length,
        monetizationEnhanced: true,
    };

    Outputs.ProcessingTime = Utils.safeGet(analysisInfo, 'metadata.processing_time', 0);
    Outputs.ConfidenceScore = Utils.safeGet(analysisInfo, 'metadata.confidence_score', 85);
        ["supabase", "enhanced_research", "monetization_analysis"];

    // ========================================================================
    // VERIFICATION LOGGING WITH AFFILIATE DATA
    // ========================================================================

    console.log("🔍 FINAL VERIFICATION:");
    console.log("GoogleTrendsOverview momentum:", Outputs.GoogleTrendsOverview?.momentum);
    console.log("PyTrends mainTopicAnalysis momentum:", Outputs.PyTrendsInsights?.mainTopicAnalysis?.momentum);
    console.log("MarketTrendSummary trendMomentum:", Outputs.MarketTrendSummary?.trendMomentum);

    // Add specific KPI momentum output
    Outputs.KPI_momentum = momentum;
    console.log("KPI_momentum output:", Outputs.KPI_momentum);

    console.log("💰 MONETIZATION VERIFICATION:");
    console.log("Total Estimated Revenue:", totalEstimatedRevenue);
    console.log("Avg Monetization Score:", Outputs.MarketTrendSummary.avgMonetizationScore);
    console.log("High Monetization Items:", Outputs.MarketTrendSummary.highMonetizationCount);
    console.log("Selected Revenue Potential:", selectedMonetizationPotential);


    // ========================================================================
    // DEBUG INFORMATION WITH AFFILIATE DATA
    // ========================================================================

    Outputs.PyTrendsDebugInfo = {
        dataFound: pytrendsAvailable,
        dataSource: pytrendsAvailable ? "metadata" : "none",
        metadataStructure: analysisData?.analysis_info?.metadata ? 
            Object.keys(analysisData.analysis_info.metadata) : [],
        pytrendsKeys: pytrendsData ? Object.keys(pytrendsData) : [],
        geographicHotspotsCount: geographicHotspots.length,
        actionableInsightsCount: actionableInsights.length,
        mainAnalysisSuccess: pytrendsData?.main_topic_analysis?.analysis_success || false,
        geographicAnalysisSuccess: pytrendsData?.geographic_insights?.analysis_success || false,
        currentInterest: currentInterest,
        momentum: momentum,
        trendDirection: trendDirection,
        topMarket: geographicHotspots.length > 0 ? geographicHotspots[0].country : "Unknown",
        timestamp: new Date().toISOString()
    };

    // Enhanced Monetization Debug Info with Affiliate Data
    Outputs.MonetizationDebugInfo = {
        monetizationEnhanced: true,
        totalItemsAnalyzed: [...trendingTopics, ...contentOpportunities].length,
        avgTopicMonetization: trendingTopics.length > 0 ? Math.round(trendingTopics.reduce((sum, t) => sum + (t.monetization_score || 0), 0) / trendingTopics.length) : 0,
        avgOppMonetization: contentOpportunities.length > 0 ? Math.round(contentOpportunities.reduce((sum, o) => sum + (o.monetization_score || 0), 0) / contentOpportunities.length) : 0,
        revenueRangeDistribution: {
            high: [...trendingTopics, ...contentOpportunities].filter(item => 
                parseInt(item.estimated_revenue_range?.split(' - ')[1]?.replace(/[$,]/g, '') || '0') >= 5000).length,
            medium: [...trendingTopics, ...contentOpportunities].filter(item => {
                const maxRevenue = parseInt(item.estimated_revenue_range?.split(' - ')[1]?.replace(/[$,]/g, '') || '0');
                return maxRevenue >= 1000 && maxRevenue < 5000;
            }).length,
            low: [...trendingTopics, ...contentOpportunities].filter(item => 
                parseInt(item.estimated_revenue_range?.split(' - ')[1]?.replace(/[$,]/g, '') || '0') < 1000).length
        },
        streamDistribution: {
            digital_product: [...trendingTopics, ...contentOpportunities]
                .filter(item => (item.monetization_streams || []).some(s => s.type === 'digital_product')).length,
            services: [...trendingTopics, ...contentOpportunities]
                .filter(item => (item.monetization_streams || []).some(s => s.type === 'services')).length,
            lead_generation: [...trendingTopics, ...contentOpportunities]
                .filter(item => (item.monetization_streams || []).some(s => s.type === 'lead_generation')).length
        },
        timestamp: new Date().toISOString()
    };


    console.log("📋 Debug Info:", Outputs.PyTrendsDebugInfo);
    console.log("💰 Monetization Debug Info:", Outputs.MonetizationDebugInfo);

    // ========================================================================
    // ========================================================================

    const successSummary = `

CORE METRICS:
- Topics: ${trendingTopics.length}
- Opportunities: ${contentOpportunities.length}
- Momentum: ${momentum}%
- Current Interest: ${currentInterest}


💰 ENHANCED MONETIZATION METRICS:
- Total Revenue Potential: ${totalEstimatedRevenue.toLocaleString()}
- Avg Monetization Score: ${Outputs.MarketTrendSummary.avgMonetizationScore}%
- High Monetization Items: ${Outputs.MarketTrendSummary.highMonetizationCount}
- Selected Revenue Potential: ${selectedMonetizationPotential.toLocaleString()}

🎯 TOP MONETIZATION STREAMS:
- Digital Products: ${Outputs.MonetizationDebugInfo.streamDistribution.digital_product} items
- Services: ${Outputs.MonetizationDebugInfo.streamDistribution.services} items
- Lead Generation: ${Outputs.MonetizationDebugInfo.streamDistribution.lead_generation} items

ENHANCED FEATURES:
✅ Enhanced monetization analysis
✅ Revenue-focused selection strategies
✅ Comprehensive monetization stream identification

`;
    console.log(successSummary);

// ========================================================================
// END OF SUCCESSFUL EXECUTION - CLOSE THE MAIN TRY BLOCK
// ========================================================================

} catch (error) {
    // Enhanced Error Handling with Affiliate Context
    
    Outputs.loading = false;
    Outputs.error = error.message || 'Unknown error occurred';
    
    // Clear all outputs on error
    const clearOutputs = [
        'MarketTrendSummary', 'TrendingTopicsList', 'ContentOpportunitiesList',
        'TrendingTopicsTableData', 'ContentOpportunitiesTableData', 'currentAnalysisId',
        'PyTrendsInsights', 'GoogleTrendsOverview', 'ActionableInsightsPanel',
        // Enhanced monetization outputs
        'MonetizationDashboard', 'MonetizationInsights', 'TopMonetizationOpportunities',
    ];
    
    clearOutputs.forEach(output => Outputs[output] = null);
    
    // Set error-specific outputs
    Outputs.UIState = {
        hasError: true,
        errorMessage: error.message || 'Unknown error occurred',
        hasData: false,
        isEmpty: true,
        hasSelections: false,
        isLoadingSelection: false,
        isLoadingData: false,
        showSuccessMessage: false,
        successMessage: '',
        lastDataUpdate: Date.now(),
        // Enhanced monetization error state
        hasMonetizationData: false,
        showMonetizationInsights: false
    };
    
    Outputs.ErrorContext = {
        errorType: error.name || 'UnknownError',
        timestamp: new Date().toISOString(),
        mode: loadMode,
        step: loadMode === 'new' ? 'trend_research_api' : 'data_loading',
        troubleshooting: {
            commonCauses: [
                "API service unavailable",
                "Invalid API keys", 
                "Database connection issues",
                "Invalid analysis ID",
                "Network connectivity problems"
            ],
            suggestedActions: [
                "Check API key validity",
                "Verify network connection",
                "Try again in a moment",
                "Contact support if issue persists",
            ]
        }
    };

    // Set fallback values
    Outputs.KPI_momentum = 0;
    
    // Fallback PyTrends outputs
    Outputs.PyTrendsInsights = {
        available: false,
        mainTopicAnalysis: {
            currentInterest: 0,
            trendDirection: "unknown",
            momentum: 0,
            peakInterest: 0,
            recommendation: "Error occurred during analysis"
        },
        geographicHotspots: [],
        seasonalPatterns: { hasPattern: false, peakMonths: [], nextPeak: null },
        relatedQueries: { topQueries: [], risingQueries: [] },
        actionableInsights: []
    };
    
    Outputs.GoogleTrendsOverview = {
        available: false,
        currentScore: 0,
        trendDirection: "unknown",
        momentum: 0,
        topMarket: "Unknown",
        nextPeakTiming: null,
        hasData: false
    };
    
    Outputs.ActionableInsightsPanel = {
        urgentActions: [],
        timingSuggestions: [],
        geographicOpportunities: [],
        hasUrgentActions: false,
        available: false
    };

    // Fallback monetization outputs
    Outputs.MonetizationDashboard = {
        overview: {
            totalEstimatedRevenue: 0,
            avgMonetizationScore: 0,
            highPotentialItems: 0,
            mediumPotentialItems: 0,
            lowPotentialItems: 0,
            itemsWithAffiliateData: 0
        },
        revenueBreakdown: { topics: 0, opportunities: 0 },
        topMonetizationItems: []
    };

    Outputs.MonetizationInsights = {
        recommendations: [],
        quickWins: [],
        revenuePotential: { immediate: 0, sixMonth: 0, annual: 0 },
    };

    Outputs.AffiliateResearchData = {
        available: false,
        profitabilityScore: 0,
        profitabilityLevel: 'Unknown',
        insights: {},
        recommendations: [],
        offerCount: 0,
        topOffers: [],
        subtopicsCovered: 0,
        shouldProceed: true
    };
}

// ============================================================================
// FINALIZE OUTPUTS
// ============================================================================

Outputs.Finished();

// ============================================================================
// ============================================================================